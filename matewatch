#! /usr/bin/env ruby
begin
  require 'rubygems'
  require 'rbosa'
  require 'getoptlong'
  require 'active_support'
rescue
  puts "matewatch requires rubygems, rubyosa, and activesupport"
end

module Matewatch
  class<<self
    def data_dir
      File.expand_path("~/.matewatch")
    end

    def run
      opts = GetoptLong.new(
        [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
        [ '--require-frontmost', '-r', GetoptLong::NO_ARGUMENT],
        [ '--verbose', '-v', GetoptLong::NO_ARGUMENT ],
        [ '--hourly', GetoptLong::NO_ARGUMENT ],
        [ '--session', GetoptLong::NO_ARGUMENT ],
        [ '--from', '-f', GetoptLong::REQUIRED_ARGUMENT],
        [ '--to', '-t', GetoptLong::REQUIRED_ARGUMENT],
        [ '--day', '-d', GetoptLong::REQUIRED_ARGUMENT],
        [ '--poll', GetoptLong::REQUIRED_ARGUMENT]
      )

      opts.each do |opt, arg|
        case opt
        when '--help'     then exit_with_msg(help_msg)
        when '--require-frontmost' then @require_frontmost = true
        when '--verbose'  then @verbose = true
        when '--from'     then @from = Time.parse(arg)
        when '--to'       then @to = Time.parse(arg)
        when '--day'      then @day = Time.parse(arg)
        when '--poll'     then @poll = arg.to_i
        when '--hourly'   then @type = 'hourly'
        when '--session'  then @type = 'session'
        end
      end

      begin
        @logger = Logger.new(@verbose)
        @mw = Watcher.new :logger => @logger, :require_frontmost => @require_frontmost
      
        save_and_exit = lambda do
          @logger.info "\nSaving"
          @mw.stop_all
          exit
        end
    
        trap 'TERM', save_and_exit
        trap 'INT', save_and_exit
  
        case command = ARGV.shift
        when 'start'
          @mw.watch(@poll || 5)
    
        when 'report'
          projects = (name = ARGV.shift) ? [@mw.project(name)] : @mw.projects
          heading = "#{"#{@type} " if @type}report"
          if @day
            heading += " " + @day.strftime("%a %d/%b/%y")
          else
            heading += @from ? " " + @from.strftime(@from.strftime("%a %d/%b/%y")) : ""
            heading += " => "
            heading += @to ? @to.strftime(@from.strftime("%a %d/%b/%y")) : Time.now.strftime("%a %d/%b/%y")
          end
          projects.each do |project|
            line = '=' * (project.name.length + heading.length + 2)
            puts "\n#{line}\n#{project.name}: #{heading}\n#{line}\n"
            puts @day ? project.day_report(@day, @type) : project.report(@from, @to, @type)
            puts
          end  
                    
        when 'list'
          printf("\n %-20s  %s\n\n", 'NAME', 'PATH')
          @mw.projects.each{|p| printf(" %-20s  %s\n", p.name, p.path)}
          puts
    
        when 'add'
          usage = "Eh? matewatch add <name> <path> [<position>]"
          @name = ARGV.shift || exit_with_msg(usage)
          @path = ARGV.shift || exit_with_msg(usage)
          @pos  = ARGV.first ? ARGV.shift.to_i : nil
          project = @mw.add_project(@name, @path, @pos)
          puts "project #{project.name} #{project.path} added"
  
        when 'remove'
          usage = "Eh? matewatch remove <name>"
          @name = ARGV.shift || exit_with_msg(@name)
          project = @mw.remove_project(@name)
          puts "project #{project.name} removed"
  
        when 'move'
          usage = "Eh? matewatch move <name> <position>"
          @name = ARGV.shift || exit_with_msg(usage)
          @pos  = (ARGV.first ? ARGV.shift.to_i : nil) || exit_with_msg(usage)
          project = @mw.move_project(@name, @pos)
          puts "project #{project.name} moved"
  
        when 'test'
          Tests.run
          
        else
          puts help_msg       
        end

      rescue
        exit_with_msg($!)
      end
    end

    def help_msg
      <<-end_str
    
  matewatch COMMAND [OPTIONS]
  
  matewatch start
    Starts the project watcher
    
    --verbose           -v            show output
    --require-frontmost -r            require that textmate be at front to
                                      log time data
    --poll=<n>          -p <n>        poll every (n) seconds
    
  matewatch report [<name>]
    Show brief report of hours/minutes per day

    --hourly OR --session             show hourly/session report
    --project=<name>    -p <name>     only report/total for <name>
    --from=<date>       -f <date>     from specified date
    --to=<date>         -t <date>     to specified date
    --day=<date>        -d <date>     for specified date

  matewatch list
    List projects being watched
    
  matewatch add <name> <path> [<position>]
    Add a project to the watch list
    
  matewatch remove <name>
    Remove a project from the watch list (no undo)
    
  matewatch move <name> <position>
    Move a project up or down the list

  If you want to get at the session data for your projects, you'll find them
  in ~/.matewatch.  The files are YAML format, and so are easily editable/ex-
  portable.  matewatch has a builtin test suite which you can invoke with the
  command 'matewatch test'.
  
    by Argument from Design (c) 2007 <http://www.ardes.com> (MIT License)
  
    end_str
    end

    def exit_with_msg(str)
      puts str
      exit
    end
  end
  
  class Logger
    def initialize(on = true)
      @on = on
    end
    
    def info(str)
      puts str if @on
    end
  end
  
  class Timer
    def initialize
      @intervals = []
    end
    
    # return nil if nothing changed
    def start
      @started_at ? false : @started_at = Time.now
    end
  
    # return nil if nothing changed
    def stop
      if @started_at
        returning [@started_at, Time.now] do |interval|
          @intervals << interval
          @started_at = nil
        end
      end
    end
  
    # return array of [start, stop] intervals which include the
    # specified period.
    def intervals(from = nil, to = nil)
      return [] if @intervals.length == 0
      return @intervals.dup if from.nil? && to.nil?

      from ||= @intervals.first.first
      to   ||= @intervals.last.last
      intervals = []
    
      @intervals.each do |start, stop|
        if from > start
          if stop > from
            stop = to if to < stop
            intervals.push [from, stop]
          end
          next
        elsif stop > to
          intervals.push [start, to] if start < to
          break
        end
        intervals.push([start, stop])
      end
      intervals
    end
    
    # return duration of intervals in between specified period
    def total(from = nil, to = nil)
      intervals(from, to).inject(0){|m, (start, stop)| m + (stop - start)}.to_i
    end
    
    # return total for a particular day
    def day_total(day = nil)
      day = day.to_time rescue Time.now
      total day.beginning_of_day, day.end_of_day + 1
    end
    
    # return total for a particular hour
    def hour_total(hour, day = nil, seconds = false)
      day = (day.to_time rescue Time.now).beginning_of_day
      hour = day + hour.hours
      total hour, hour + 1.hour
    end
  end
  
  class Project
    attr_reader :timer, :name, :path
    attr_writer :logger
    
    def self.load(name)
      YAML.load_file(Matewatch.data_dir + "/#{name}.yml")
    end
    
    def initialize(name, path)
      @name = name
      @path = File.expand_path(path)
      @timer = Timer.new
    end
    
    def logger
      @logger ||= Logger.new
    end
    
    def stop
      if timer.stop
        logger.info "[ ] #{name} stopped at #{Time.now}"
        save
      end
    end
    
    def start
      if timer.start
        logger.info "[#] #{name} started at #{Time.now}"
        save
      end
    end
    
    def total(from = nil, to = nil)
      humanize(timer.total(from, to))
    end

    def day_report(day = nil, type = nil)
      day = day.to_time rescue Time.now
      out = " - #{day.strftime('%d/%b/%y')}  #{humanize(timer.day_total(day))}"
      if type == 'hourly'
        out + "\n" + day_hourly_report(day) + "\n"
      elsif type == 'session'
        out + "\n" + day_session_report(day) + "\n"
      else
        out
      end
    end

    def report(from = nil, to = nil, type = nil)
      return "\nNo session data exists\n" if timer.intervals.length == 0
      from ||= timer.intervals.first.first
      to   ||= Time.now
      day, days = from, []
      while day < to
        days << day_report(day, type) if timer.day_total(day) > 0
        day += 1.day
      end
      days.join("\n") + "\n ----- TOTAL: #{total(from, to)}\n"
    end

    def save
      `mkdir -p #{Matewatch.data_dir}`
      File.open(Matewatch.data_dir + "/#{name}.yml", 'w+') {|f| f << to_yaml}
    end
    
    def to_yaml_properties
      ['@name', '@path', '@timer']
    end
    
  protected
    # returns nil if there is no time - so you can decide not to printor write '0 minutes' or whatever
    def humanize(seconds)
      seconds = seconds.to_i
      hours, mins, secs = seconds / 1.hour, (seconds % 1.hour) / 1.minute, seconds%60
      sprintf("%3d:%02d:%02d", hours, mins, secs)
    end

    def day_hourly_report(day = nil)
      hours = []
      (0..23).to_a.each do |hour|
        if (ht = timer.hour_total(hour, day)) > 0
          hours << sprintf("     %2d00-%-2d00  %s", hour, (hour+1)%24, humanize(ht))
        end
      end
      hours.join("\n")
    end

    def day_session_report(day = nil)
      day = day.to_time rescue Time.now
      idx = 0
      items = timer.intervals(day.beginning_of_day, day.end_of_day + 1).collect do |start, stop|
        sprintf "    %2d.  %s-%s  %s", idx+=1, start.strftime("%H:%M"), stop.strftime("%H:%M"), humanize(stop-start)
      end
      items.join("\n")
    end
  end
  
  class Watcher
    attr_reader :projects, :require_frontmost
    attr_writer :logger

    def initialize(options = {})
      @textmate = OSA::app("Textmate")
      @require_frontmost = options[:require_frontmost]
      @logger = options[:logger]
      
      project_names = YAML.load_file("#{Matewatch.data_dir}/.projects.yml") rescue []
      @projects = project_names.collect {|p| p = Project.load(p)}
      @projects.reject!(&:nil?)
      @projects.each {|p| p.logger = logger}
    end
  
    def logger
      @logger ||= Logger.new
    end
    
    def project(name)
      @projects.find {|p| p.name == name}
    end
  
    def add_project(name, path, pos = nil)
      raise "#{name} is already beng watched" if project(name)
      returning Project.new(name, path) do |p|
        p.logger = logger
        pos ? projects.insert(pos, p) : projects.push(p)
        save_projects
        p.save
      end
    end

    def move_project(name, pos)
      raise "#{name} is not being watched" unless p = project(name)
      returning projects.delete(p) do |p|
        projects.insert(pos, p)
        save_projects
      end
    end
    
    def remove_project(name)
      raise "#{name} is not being watched" unless p = project(name)
      returning projects.delete(p) do |p|
        save_projects
      end
    end
  
    def watch(poll = 1)
      poll = 1 if poll.to_i < 1
      i, textmate_gone = 0, false
    
      logger.info "matewatching: #{projects.collect(&:name).to_sentence}\npoll: #{poll} seconds, require frontmost: #{@require_frontmost ? 'true' : 'false'}\n"
      
      loop do
        begin
          raise 'tm went away' if @require_frontmost && !@textmate.frontmost?
          active = active_now
          logger.info "#{Time.now}: Textmate came back" if textmate_gone
          textmate_gone = false
        rescue RuntimeError
          logger.info "#{Time.now}: Textmate went away" unless textmate_gone
          textmate_gone = true
        end
      
        to_stop = @projects
        if !textmate_gone && active
          to_stop = @projects - [active]
          active.start
        end
        to_stop.each(&:stop)
        
        sleep(poll)
      end
    end
    
    def stop_all
      @projects.each(&:stop)
    end
  
  protected
    def save_projects
      File.open("#{Matewatch.data_dir}/.projects.yml", 'w+') {|f| f << @projects.collect(&:name).to_yaml}
    end
    
    # return the active document
    def active_now
      if @textmate.documents.first
        active_path = @textmate.documents.first.path
        @projects.find {|p| active_path =~ /^#{p.path}/}
      end
    end
  end

  # there's a bit module magicky stuff, the purpose of which is to avoid
  # loading the test suite before it's needed.
  #
  # Summary: any modules that end in Test in this module will be included
  # into anonymous TestCase classes which will be added to the suite
  module Tests
    class<<self
      def run
        require 'test/unit/testcase'
        require 'test/unit/testsuite'
        require 'test/unit/ui/console/testrunner'
        setup_tests
        
        # change data dir for tests
        class<<Matewatch
          def data_dir
            File.expand_path("~/.matewatch/.test")
          end
        end
        `mkdir -p #{Matewatch.data_dir}`
        
        Test::Unit::UI::Console::TestRunner.run(Matewatch::Tests)   
      end
      
      def suite
        suite = Test::Unit::TestSuite.new('Matewatch::Tests')
        @tests.each {|t| suite << t.suite}
        suite
      end
    
      def setup_tests
        @tests = []
        constants.select{|c| c =~ /Test$/}.each do |test_module|
          test = Class.new(Test::Unit::TestCase)
          test.send :include, eval(test_module)
          @tests << test
        end
      end 
    end
    
    module TimerTest
      def setup
        @timer = Timer.new
      end

      def test_intervals
        assert_equal [], @timer.intervals
        assert_equal [], @timer.intervals(Time.now)
        assert_equal [], @timer.intervals(nil, Time.now)
        assert_equal [], @timer.intervals(Time.now - 10000, Time.now)
      end
      
      def test_total_seconds
        assert_equal 0, @timer.total
        assert_equal 0, @timer.total(Time.now)
        assert_equal 0, @timer.total(nil, Time.now)
        assert_equal 0, @timer.total(Time.now - 10000, Time.now)
      end
      
      def test_start_should_set_started_at
        @timer.start
        started_at = @timer.instance_variable_get('@started_at')
        assert started_at.is_a?(Time)
      end
      
      def test_start_twice_should_do_nothing
        @timer.start
        started_at = @timer.instance_variable_get('@started_at')
        sleep(0.1)
        @timer.start
        assert_equal started_at, @timer.instance_variable_get('@started_at')
      end
      
      def test_stop_without_start_should_do_nothing
        @timer.stop
        assert_equal [], @timer.intervals
      end
      
      def test_start_then_stop_should_create_interval
        @timer.start
        started_at = @timer.instance_variable_get('@started_at')
        sleep(0.1)
        @timer.stop
        assert_equal started_at, @timer.intervals.last.first
        assert @timer.intervals.last.last > started_at
      end
      
      def test_intervals_should_include_started_session
        @timer.start
        started_at = @timer.instance_variable_get('@started_at')
        interval = @timer.intervals.first
        assert_equal started_at, interval.first
        assert interval.last.is_a?(Time)
        assert interval.last > started_at
      end
    end
    
    module TimerDataSetup
      def setup_timer
        @s1_start = Time.parse('2007/01/01 09:55')
        @s1_stop  = Time.parse('2007/01/01 10:05')
        @s2_start = Time.parse('2007/01/01 23:55')
        @s2_stop  = Time.parse('2007/01/02 00:05')
        @s3_start = Time.parse('2007/01/02 10:55')
        @s3_stop  = Time.parse('2007/01/02 12:05')
        @timer = Timer.new
        @timer.instance_variable_set('@intervals', [[@s1_start, @s1_stop], [@s2_start, @s2_stop], [@s3_start, @s3_stop]])
      end
    end
    
    module TimerWithDataTest
      include TimerDataSetup
      
      def setup
        setup_timer
      end
      
      def test_intervals_total_no_args
        assert_equal [[@s1_start, @s1_stop], [@s2_start, @s2_stop], [@s3_start, @s3_stop]], @timer.intervals
        assert_equal 90.minutes, @timer.total
      end

      def test_before_s1_to_after_s1
        assert_equal [[@s1_start, @s1_stop]], @timer.intervals(@s1_start-5, @s1_stop+5)
        assert_equal 10.minutes, @timer.total(@s1_start-5, @s1_stop+5)
      end
            
      def test_from_s1_to_after_s1
        assert_equal [[@s1_start, @s1_stop]], @timer.intervals(@s1_start, @s1_stop+5)
        assert_equal 10.minutes, @timer.total(@s1_start, @s1_stop+5)
      end
      
      def test_from_after_s1_start_to_after_s1
        assert_equal [[@s1_start+5, @s1_stop]], @timer.intervals(@s1_start+5, @s1_stop+5)
        assert_equal 10.minutes - 5.seconds, @timer.total(@s1_start+5, @s1_stop+5)
      end

      def test_from_after_s1_start_to_before_s1_stop
        assert_equal [[@s1_start+5, @s1_stop-5]], @timer.intervals(@s1_start+5, @s1_stop-5)
        assert_equal 10.minutes - 10.seconds, @timer.total(@s1_start+5, @s1_stop-5)
      end
      
      def test_from_after_s1_start_to_after_s2_start
        assert_equal [[@s1_start+5, @s1_stop], [@s2_start, @s2_start+20]], @timer.intervals(@s1_start+5, @s2_start+20)
        assert_equal 10.minutes + 15.seconds, @timer.total(@s1_start+5, @s2_start+20)
      end

      def test_day_total
        assert_equal 15.minutes, @timer.day_total('2007/01/01')
        assert_equal 75.minutes, @timer.day_total('2007/01/02')
      end
      
      def test_hour_total
        assert_equal 5.minutes, @timer.hour_total(9, '2007/01/01')
        assert_equal 5.minutes, @timer.hour_total(10, '2007/01/01')
        assert_equal 0, @timer.hour_total(11, '2007/01/01')
        assert_equal 5.minutes, @timer.hour_total(23, '2007/01/01')
        assert_equal 5.minutes, @timer.hour_total(0, '2007/01/02')
        assert_equal 0, @timer.hour_total(1, '2007/01/02')
      end
    end
    
    module ProjectTest
      include TimerDataSetup
      
      def setup
        setup_timer
        `rm -f #{Matewatch.data_dir}/test.yml`
        @project = Project.new('test', '/path')
        @project.logger = Logger.new(false)
        @project.instance_variable_set('@timer', @timer)
      end
      
      def test_save_on_start
        @project.start
        yaml = YAML.load_file("#{Matewatch.data_dir}/test.yml")
        assert_equal @project.timer.instance_variable_get('@intervals'), yaml.timer.instance_variable_get('@intervals')
        assert_equal @project.timer.instance_variable_get('@started_at'), yaml.timer.instance_variable_get('@started_at')
        assert_equal @project.name, yaml.name
        assert_equal @project.path, yaml.path
      end
      
      def test_intervals_total_no_args
        assert_equal "1 hour, 30 minutes", @project.total
      end

      def test_before_s1_to_after_s1
        assert_equal "10 minutes", @project.total(@s1_start-5, @s1_stop+5)
      end
            
      def test_from_s1_to_after_s1
        assert_equal "10 minutes", @project.total(@s1_start, @s1_stop+5)
      end
      
      def test_from_after_s1_start_to_after_s1
        assert_equal "10 minutes", @project.total(@s1_start+5, @s1_stop+5)
      end

      def test_from_after_s1_start_to_before_s1_stop
        assert_equal "10 minutes", @project.total(@s1_start+5, @s1_stop-5)
      end
      
      def test_from_after_s1_start_to_after_s2_start
        assert_equal "11 minutes", @project.total(@s1_start+5, @s2_start+20)
      end
      
      def test_day_report
        assert_equal " - 01/Jan/07  15 minutes", @project.day_report('2007/01/01')
        assert_equal " - 01/Jan/07  15 minutes\n      9-10  5 minutes\n     10-11  5 minutes\n     23-24  5 minutes\n", 
          @project.day_report('2007/01/01', 'hourly')
        assert_equal " - 02/Jan/07  1 hour, 15 minutes\n      0-1   5 minutes\n     10-11  5 minutes\n     11-12  1 hour\n     12-13  5 minutes\n", 
          @project.day_report('2007/01/02', 'hourly')
        assert_equal " - 01/Jan/07  15 minutes\n     1.  09:55-10:05  10 minutes\n     2.  23:55-00:00  5 minutes\n", 
          @project.day_report('2007/01/01', 'session')
        assert_equal " - 02/Jan/07  1 hour, 15 minutes\n     1.  00:00-00:05  5 minutes\n     2.  10:55-12:05  1 hour, 10 minutes\n", 
          @project.day_report('2007/01/02', 'session')
      end
      
      def test_report
        assert_equal " - 01/Jan/07  15 minutes\n - 02/Jan/07  1 hour, 15 minutes\n TOTAL: 1 hour, 30 minutes\n",
          @project.report
        assert_equal " - 01/Jan/07  15 minutes\n     1.  09:55-10:05  10 minutes\n     2.  23:55-00:00  5 minutes\n\n - 02/Jan/07  1 hour, 15 minutes\n     1.  00:00-00:05  5 minutes\n     2.  10:55-12:05  1 hour, 10 minutes\n\n TOTAL: 1 hour, 30 minutes\n",
           @project.report(nil, nil, 'session')
        assert_equal " - 01/Jan/07  15 minutes\n      9-10  5 minutes\n     10-11  5 minutes\n     23-24  5 minutes\n\n - 02/Jan/07  1 hour, 15 minutes\n      0-1   5 minutes\n     10-11  5 minutes\n     11-12  1 hour\n     12-13  5 minutes\n\n TOTAL: 1 hour, 30 minutes\n",
          @project.report(nil, nil, 'hourly')
      end
    end
  end
end

Matewatch.run